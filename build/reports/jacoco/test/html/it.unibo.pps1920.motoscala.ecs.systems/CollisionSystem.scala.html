<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CollisionSystem.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pps-19-motoScala</a> &gt; <a href="index.source.html" class="el_package">it.unibo.pps1920.motoscala.ecs.systems</a> &gt; <span class="el_source">CollisionSystem.scala</span></div><h1>CollisionSystem.scala</h1><pre class="source lang-java linenums">package it.unibo.pps1920.motoscala.ecs.systems

import it.unibo.pps1920.motoscala.ecs.components.Shape.Circle
import it.unibo.pps1920.motoscala.ecs.components._
import it.unibo.pps1920.motoscala.ecs.managers.{Coordinator, ECSSignature}
import it.unibo.pps1920.motoscala.ecs.util.Direction
import it.unibo.pps1920.motoscala.ecs.{AbstractSystem, Entity, System}


<span class="nc" id="L10">object CollisionSystem {</span>
/*  def apply(coordinator: Coordinator, fps: Int): System = new CollisionSystemImpl(coordinator, fps)
  private class CollisionSystemImpl(coordinator: Coordinator, fps: Int)
    extends AbstractSystem(ECSSignature(classOf[PositionComponent],
                                        classOf[DirectionComponent],
                                        classOf[ShapeComponent],
                                        classOf[CollisionComponent],
                                        classOf[VelocityComponent])) {

    def update(): Unit = {
      entitiesRef().foreach(e =&gt; {
        val col = coordinator.getEntityComponent(e, classOf[CollisionComponent]).get.asInstanceOf[CollisionComponent]
        val dir = coordinator.getEntityComponent(e, classOf[DirectionComponent]).get.asInstanceOf[DirectionComponent]
        //collision already happening
        if (col.isColliding) {
          if (col.duration &gt; 0) {
            col.duration -= 1
            dir.dir = col.colDirection
          } else {
            dir.dir = Direction.Center
            //coordinator.getEntityComponent(e, classOf[VelocityComponent]).get.asInstanceOf[VelocityComponent].vel = col
            //  .oldSpeed
            col.isColliding = false
          }
        } else {
          val shapeC = coordinator.getEntityComponent(e, classOf[ShapeComponent]).get.asInstanceOf[ShapeComponent]
          val posC = coordinator.getEntityComponent(e, classOf[PositionComponent]).get.asInstanceOf[PositionComponent]
          entitiesRef().filter(other =&gt; other.uuid != e.uuid).foreach(other =&gt; {
            val shapeCo = coordinator.getEntityComponent(other, classOf[ShapeComponent]).get
              .asInstanceOf[ShapeComponent]
            val posCo = coordinator.getEntityComponent(other, classOf[PositionComponent]).get
              .asInstanceOf[PositionComponent]
            (shapeC.shape, shapeCo.shape) match {
              case (Circle(radius), Circle(radius2)) =&gt; if ((posC.pos dist posCo.pos) &lt;= (radius + radius2))
                bounce(e, other)
              case _ =&gt;
            }
          })
        }
      })
    }
    def bounce(e1: Entity, e2: Entity): Unit = {
      val dir1 = coordinator.getEntityComponent(e1, classOf[DirectionComponent]).get.asInstanceOf[DirectionComponent]
      val dir2 = coordinator.getEntityComponent(e2, classOf[DirectionComponent]).get.asInstanceOf[DirectionComponent]
      val col1 = coordinator.getEntityComponent(e1, classOf[CollisionComponent]).get.asInstanceOf[CollisionComponent]
      val col2 = coordinator.getEntityComponent(e2, classOf[CollisionComponent]).get.asInstanceOf[CollisionComponent]
      col1.inputDirection = dir1.dir
      col1.colDirection = dir2.dir + dir1.dir.opposite()
      val duration1: Int = (((col2.mass * fps) / (10 * fps)) * (fps / 5)).toInt
      col1.duration = duration1
      val vel1 = coordinator.getEntityComponent(e1, classOf[VelocityComponent]).get.asInstanceOf[VelocityComponent]
      //col1.oldSpeed = vel1.vel
      //vel1.vel = 30
      col1.isColliding = true
    }
  }*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>